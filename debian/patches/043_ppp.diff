
we don't link against libmd since it's not on debian
http://martin.hinner.info/libmd/

--- a/usr.sbin/ppp/Makefile
+++ b/usr.sbin/ppp/Makefile
@@ -38,11 +38,11 @@
 BINMODE=4550
 BINOWN=	root
 .endif
-BINGRP=	network
+BINGRP=	dialout
 M4FLAGS=
 
-LDADD= -lcrypt -lmd -lutil -lz
-DPADD=	${LIBCRYPT} ${LIBMD} ${LIBUTIL} ${LIBZ}
+LDADD= -lcrypt -lbsd -lutil -lz
+DPADD=	${LIBCRYPT} ${LIBUTIL} ${LIBZ}
 
 .SUFFIXES: .8 .8.m4
 
@@ -79,6 +79,7 @@
 
 .if defined(PPP_NO_SUID)
 CFLAGS+=-DNOSUID
+LDADD+= -llockdev
 .else
 SRCS+=	id.c
 .endif
--- a/usr.sbin/ppp/bundle.c
+++ b/usr.sbin/ppp/bundle.c
@@ -1629,7 +1634,11 @@
         log_Printf(LogDEBUG, "Received confirmation from pid %ld\n",
                    (long)newpid);
         if (lock && (res = ID0uu_lock_txfr(lock, newpid)) != UU_LOCK_OK)
+#if defined(__linux__) || defined(__GNU__) || defined(__GLIBC__)
+            log_Printf(LogERROR, "lock transfer failed");
+#else
             log_Printf(LogERROR, "uu_lock_txfr: %s\n", uu_lockerr(res));
+#endif
 
         log_Printf(LogDEBUG, "Transmitting link (%d bytes)\n", expect);
         if ((got = writev(reply[0], iov + 1, niov - 1)) != expect) {
--- a/usr.sbin/ppp/id.h
+++ b/usr.sbin/ppp/id.h
@@ -63,9 +63,18 @@
 #define ID0fopen fopen
 #define ID0open open
 #define ID0write write
+
+#if defined(__linux__) || defined(__GNU__) || defined(__GLIBC__)
+#include <lockdev.h>
+#define ID0uu_lock dev_lock
+#define ID0uu_lock_txfr dev_relock
+#define ID0uu_unlock dev_unlock
+#define UU_LOCK_OK 0
+#else /* on BSD */
 #define ID0uu_lock uu_lock
 #define ID0uu_lock_txfr uu_lock_txfr
 #define ID0uu_unlock uu_unlock
+#endif
 #define ID0login pututxline
 #define ID0logout pututxline
 #define ID0bind_un(s, n) bind(s, (const struct sockaddr *)(n), sizeof *(n))
--- a/usr.sbin/ppp/physical.c
+++ b/usr.sbin/ppp/physical.c
@@ -307,11 +309,15 @@
 
   if (*p->name.full == '/' && p->type != PHYS_DIRECT &&
       (res = ID0uu_lock(p->name.base)) != UU_LOCK_OK) {
+#if defined(__linux__) || defined(__GNU__) || defined(__GLIBC__)
+    log_Printf(LogPHASE, "%s: %s is in use\n", p->link.name, p->name.full);
+#else
     if (res == UU_LOCK_INUSE)
       log_Printf(LogPHASE, "%s: %s is in use\n", p->link.name, p->name.full);
     else
       log_Printf(LogPHASE, "%s: %s is in use: uu_lock: %s\n",
                  p->link.name, p->name.full, uu_lockerr(res));
+#endif
     return 0;
   }
 
@@ -322,7 +328,12 @@
 physical_Unlock(struct physical *p)
 {
   if (*p->name.full == '/' && p->type != PHYS_DIRECT &&
-      ID0uu_unlock(p->name.base) == -1)
+#if defined(__linux__) || defined(__GNU__) || defined(__GLIBC__)
+      ID0uu_unlock(p->name.base, 0) == -1
+#else
+      ID0uu_unlock(p->name.base) == -1
+#endif
+      )
     log_Printf(LogALERT, "%s: Can't uu_unlock %s\n", p->link.name,
                p->name.base);
 }
@@ -761,7 +772,11 @@
     int res;
 
     if ((res = ID0uu_lock_txfr(p->name.base, newpid)) != UU_LOCK_OK)
+#if defined(__linux__) || defined(__GNU__) || defined(__GLIBC__)
+      log_Printf(LogPHASE, "uu_lock_txfr");
+#else
       log_Printf(LogPHASE, "uu_lock_txfr: %s\n", uu_lockerr(res));
+#endif
   }
 }
 
